{"version":3,"file":"audio-recorder-polyfill-es.umd.js","sources":["../../src/index.js","../../src/createWorker.js","../../src/wave-encoder.js"],"sourcesContent":["import createWorker from './createWorker.js';\nimport encoder from './wave-encoder.js';\n\nconst AudioContext = window.AudioContext || window.webkitAudioContext;\n\n/**\n * Audio Recorder with MediaRecorder API.\n *\n * @param {MediaStream} stream The audio stream to record.\n *\n * @example\n * navigator.mediaDevices.getUserMedia({ audio: true }).then(function (stream) {\n *   var recorder = new MediaRecorder(stream)\n * })\n *\n * @class\n */\nclass MediaRecorder {\n  /**\n   * The `MediaStream` passed into the constructor.\n   * @type {MediaStream}\n   */\n  constructor(stream) {\n    this.mimeType = 'audio/wav';\n    this.stream = stream;\n    /**\n     * The current state of recording process.\n     * @type {\"inactive\"|\"recording\"|\"paused\"}\n     */\n    this.state = 'inactive'\n  \n    this.em = document.createDocumentFragment()\n    this.encoder = createWorker(MediaRecorder.encoder);\n  \n    const recorder = this\n    this.encoder.addEventListener('message', function (e) {\n      const event = new Event('dataavailable')\n      event.data = new Blob([e.data], { type: recorder.mimeType })\n      recorder.em.dispatchEvent(event)\n      if (recorder.state === 'inactive') {\n        recorder.em.dispatchEvent(new Event('stop'))\n      }\n    });\n  }\n  /**\n   * Begins recording media.\n   *\n   * @param {number} [timeslice] The milliseconds to record into each `Blob`.\n   *                             If this parameter isnâ€™t included, single `Blob`\n   *                             will be recorded.\n   *\n   * @return {undefined}\n   *\n   * @example\n   * recordButton.addEventListener('click', function () {\n    *   recorder.start()\n    * })\n    */\n   start(timeslice) {\n     if (this.state === 'inactive') {\n       this.state = 'recording'\n \n       this.context = new AudioContext()\n       var input = this.context.createMediaStreamSource(this.stream)\n       var processor = this.context.createScriptProcessor(2048, 1, 1)\n \n       var recorder = this\n       processor.onaudioprocess = function (e) {\n         if (recorder.state === 'recording') {\n           recorder.encoder.postMessage([\n             'encode', e.inputBuffer.getChannelData(0)\n           ])\n         }\n       }\n \n       input.connect(processor)\n       processor.connect(this.context.destination)\n \n       this.em.dispatchEvent(new Event('start'))\n \n       if (timeslice) {\n         this.slicing = setInterval(function () {\n           if (recorder.state === 'recording') recorder.requestData()\n         }, timeslice)\n       }\n     }\n   }\n \n   /**\n    * Stop media capture and raise `dataavailable` event with recorded data.\n    *\n    * @return {undefined}\n    *\n    * @example\n    * finishButton.addEventListener('click', function () {\n    *   recorder.stop()\n    * })\n    */\n   stop() {\n     if (this.state !== 'inactive') {\n       this.requestData()\n       this.state = 'inactive'\n       clearInterval(this.slicing)\n     }\n   }\n \n   /**\n    * Pauses recording of media streams.\n    *\n    * @return {undefined}\n    *\n    * @example\n    * pauseButton.addEventListener('click', function () {\n    *   recorder.pause()\n    * })\n    */\n   pause() {\n     if (this.state === 'recording') {\n       this.state = 'paused'\n       this.em.dispatchEvent(new Event('pause'))\n     }\n   }\n \n   /**\n    * Resumes media recording when it has been previously paused.\n    *\n    * @return {undefined}\n    *\n    * @example\n    * resumeButton.addEventListener('click', function () {\n    *   recorder.resume()\n    * })\n    */\n   resume() {\n     if (this.state === 'paused') {\n       this.state = 'recording'\n       this.em.dispatchEvent(new Event('resume'))\n     }\n   }\n \n   /**\n    * Raise a `dataavailable` event containing the captured media.\n    *\n    * @return {undefined}\n    *\n    * @example\n    * this.on('nextData', function () {\n    *   recorder.requestData()\n    * })\n    */\n   requestData() {\n     if (this.state !== 'inactive') {\n       this.encoder.postMessage(['dump', this.context.sampleRate])\n     }\n   }\n \n   /**\n    * Add listener for specified event type.\n    *\n    * @param {\"start\"|\"stop\"|\"pause\"|\"resume\"|\"dataavailable\"} type Event type.\n    * @param {function} listener The listener function.\n    *\n    * @return {undefined}\n    *\n    * @example\n    * recorder.addEventListener('dataavailable', function (e) {\n    *   audio.src = URL.createObjectURL(e.data)\n    * })\n    */\n   addEventListener() {\n     this.em.addEventListener.apply(this.em, arguments)\n   }\n \n   /**\n    * Remove event listener.\n    *\n    * @param {\"start\"|\"stop\"|\"pause\"|\"resume\"|\"dataavailable\"} type Event type.\n    * @param {function} listener The same function used in `addEventListener`.\n    *\n    * @return {undefined}\n    */\n   removeEventListener() {\n     this.em.removeEventListener.apply(this.em, arguments)\n   }\n \n   /**\n    * Calls each of the listeners registered for a given event.\n    *\n    * @param {Event} event The event object.\n    *\n    * @return {boolean} Is event was no canceled by any listener.\n    */\n   dispatchEvent() {\n     this.em.dispatchEvent.apply(this.em, arguments)\n   }\n}\n\n/**\n * Returns `true` if the MIME type specified is one the polyfill can record.\n *\n * This polyfill supports only `audio/wav`.\n *\n * @param {string} mimeType The mimeType to check.\n *\n * @return {boolean} `true` on `audio/wav` MIME type.\n */\nMediaRecorder.isTypeSupported = function isTypeSupported(mimeType) {\n  return /audio\\/wave?/.test(mimeType)\n}\n\n/**\n * `true` if MediaRecorder can not be polyfilled in the current browser.\n * @type {boolean}\n *\n * @example\n * if (MediaRecorder.notSupported) {\n *   showWarning('Audio recording is not supported in this browser')\n * }\n */\nMediaRecorder.notSupported = !navigator.mediaDevices || !AudioContext;\n/**\n * Converts RAW audio buffer to compressed audio files.\n * It will be loaded to Web Worker.\n * By default, WAVE encoder will be used.\n * @type {function}\n *\n * @example\n * MediaRecorder.prototype.mimeType = 'audio/ogg'\n * MediaRecorder.encoder = oggEncoder\n */\nMediaRecorder.encoder = encoder;\n\nexport default MediaRecorder\n","export default function createWorker(fn) {\n    var js = fn\n        .toString()\n        .replace(/^function\\s*\\(\\)\\s*{/, '')\n        .replace(/}$/, '')\n    var blob = new Blob([js])\n    return new Worker(URL.createObjectURL(blob))\n}","// Copied from https://github.com/chris-rudmin/Recorderjs\n\nexport default function waveEncoder() {\n  var BYTES_PER_SAMPLE = 2\n\n  var recorded = []\n\n  function encode (buffer) {\n    var length = buffer.length\n    var data = new Uint8Array(length * BYTES_PER_SAMPLE)\n    for (var i = 0; i < length; i++) {\n      var index = i * BYTES_PER_SAMPLE\n      var sample = buffer[i]\n      if (sample > 1) {\n        sample = 1\n      } else if (sample < -1) {\n        sample = -1\n      }\n      sample = sample * 32768\n      data[index] = sample\n      data[index + 1] = sample >> 8\n    }\n    recorded.push(data)\n  }\n\n  function dump (sampleRate) {\n    var bufferLength = recorded.length ? recorded[0].length : 0\n    var length = recorded.length * bufferLength\n    var wav = new Uint8Array(44 + length)\n    var view = new DataView(wav.buffer)\n\n    // RIFF identifier 'RIFF'\n    view.setUint32(0, 1380533830, false)\n    // file length minus RIFF identifier length and file description length\n    view.setUint32(4, 36 + length, true)\n    // RIFF type 'WAVE'\n    view.setUint32(8, 1463899717, false)\n    // format chunk identifier 'fmt '\n    view.setUint32(12, 1718449184, false)\n    // format chunk length\n    view.setUint32(16, 16, true)\n    // sample format (raw)\n    view.setUint16(20, 1, true)\n    // channel count\n    view.setUint16(22, 1, true)\n    // sample rate\n    view.setUint32(24, sampleRate, true)\n    // byte rate (sample rate * block align)\n    view.setUint32(28, sampleRate * BYTES_PER_SAMPLE, true)\n    // block align (channel count * bytes per sample)\n    view.setUint16(32, BYTES_PER_SAMPLE, true)\n    // bits per sample\n    view.setUint16(34, 8 * BYTES_PER_SAMPLE, true)\n    // data chunk identifier 'data'\n    view.setUint32(36, 1684108385, false)\n    // data chunk length\n    view.setUint32(40, length, true)\n\n    for (var i = 0; i < recorded.length; i++) {\n      wav.set(recorded[i], i * bufferLength + 44)\n    }\n\n    recorded = []\n    postMessage(wav.buffer, [wav.buffer])\n  }\n\n  onmessage = function (e) {\n    if (e.data[0] === 'encode') {\n      encode(e.data[1])\n    } else {\n      dump(e.data[1])\n    }\n  }\n}\n"],"names":["AudioContext","window","webkitAudioContext","MediaRecorder","constructor","stream","js","blob","mimeType","state","em","document","createDocumentFragment","encoder","toString","replace","Blob","Worker","URL","createObjectURL","recorder","this","addEventListener","e","event","Event","data","type","dispatchEvent","start","timeslice","context","input","createMediaStreamSource","processor","createScriptProcessor","onaudioprocess","postMessage","inputBuffer","getChannelData","connect","destination","slicing","setInterval","requestData","stop","clearInterval","pause","resume","sampleRate","apply","arguments","removeEventListener","isTypeSupported","test","notSupported","navigator","mediaDevices","BYTES_PER_SAMPLE","recorded","onmessage","buffer","length","Uint8Array","i","index","sample","push","encode","bufferLength","wav","view","DataView","setUint32","setUint16","set","dump"],"mappings":"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"}