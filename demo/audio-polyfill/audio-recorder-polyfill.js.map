{"version":3,"file":"audio-recorder-polyfill.js","sources":["../../src/index.js","../../src/createWorker.js","../../src/wave-encoder.js"],"sourcesContent":["import createWorker from './createWorker.js';\nimport encoder from './wave-encoder.js';\n\nvar AudioContext = window.AudioContext || window.webkitAudioContext;\n\n/**\n * Audio Recorder with MediaRecorder API.\n *\n * @param {MediaStream} stream The audio stream to record.\n *\n * @example\n * navigator.mediaDevices.getUserMedia({ audio: true }).then(function (stream) {\n *   var recorder = new MediaRecorder(stream)\n * })\n *\n * @class\n */\nfunction MediaRecorder(stream) {\n  /**\n   * The `MediaStream` passed into the constructor.\n   * @type {MediaStream}\n   */\n  this.stream = stream\n\n  /**\n   * The current state of recording process.\n   * @type {\"inactive\"|\"recording\"|\"paused\"}\n   */\n  this.state = 'inactive'\n\n  this.em = document.createDocumentFragment()\n  this.encoder = createWorker(MediaRecorder.encoder);\n\n  var recorder = this\n  this.encoder.addEventListener('message', function (e) {\n    var event = new Event('dataavailable')\n    event.data = new Blob([e.data], { type: recorder.mimeType })\n    recorder.em.dispatchEvent(event)\n    if (recorder.state === 'inactive') {\n      recorder.em.dispatchEvent(new Event('stop'))\n    }\n  })\n}\n\nMediaRecorder.prototype = {\n  /**\n   * The MIME type that is being used for recording.\n   * @type {string}\n   */\n  mimeType: 'audio/wav',\n\n  /**\n   * Begins recording media.\n   *\n   * @param {number} [timeslice] The milliseconds to record into each `Blob`.\n   *                             If this parameter isnâ€™t included, single `Blob`\n   *                             will be recorded.\n   *\n   * @return {undefined}\n   *\n   * @example\n   * recordButton.addEventListener('click', function () {\n   *   recorder.start()\n   * })\n   */\n  start: function start (timeslice) {\n    if (this.state === 'inactive') {\n      this.state = 'recording'\n\n      this.context = new AudioContext()\n      var input = this.context.createMediaStreamSource(this.stream)\n      var processor = this.context.createScriptProcessor(2048, 1, 1)\n\n      var recorder = this\n      processor.onaudioprocess = function (e) {\n        if (recorder.state === 'recording') {\n          recorder.encoder.postMessage([\n            'encode', e.inputBuffer.getChannelData(0)\n          ])\n        }\n      }\n\n      input.connect(processor)\n      processor.connect(this.context.destination)\n\n      this.em.dispatchEvent(new Event('start'))\n\n      if (timeslice) {\n        this.slicing = setInterval(function () {\n          if (recorder.state === 'recording') recorder.requestData()\n        }, timeslice)\n      }\n    }\n  },\n\n  /**\n   * Stop media capture and raise `dataavailable` event with recorded data.\n   *\n   * @return {undefined}\n   *\n   * @example\n   * finishButton.addEventListener('click', function () {\n   *   recorder.stop()\n   * })\n   */\n  stop: function stop () {\n    if (this.state !== 'inactive') {\n      this.requestData()\n      this.state = 'inactive'\n      clearInterval(this.slicing)\n    }\n  },\n\n  /**\n   * Pauses recording of media streams.\n   *\n   * @return {undefined}\n   *\n   * @example\n   * pauseButton.addEventListener('click', function () {\n   *   recorder.pause()\n   * })\n   */\n  pause: function pause () {\n    if (this.state === 'recording') {\n      this.state = 'paused'\n      this.em.dispatchEvent(new Event('pause'))\n    }\n  },\n\n  /**\n   * Resumes media recording when it has been previously paused.\n   *\n   * @return {undefined}\n   *\n   * @example\n   * resumeButton.addEventListener('click', function () {\n   *   recorder.resume()\n   * })\n   */\n  resume: function resume () {\n    if (this.state === 'paused') {\n      this.state = 'recording'\n      this.em.dispatchEvent(new Event('resume'))\n    }\n  },\n\n  /**\n   * Raise a `dataavailable` event containing the captured media.\n   *\n   * @return {undefined}\n   *\n   * @example\n   * this.on('nextData', function () {\n   *   recorder.requestData()\n   * })\n   */\n  requestData: function requestData () {\n    if (this.state !== 'inactive') {\n      this.encoder.postMessage(['dump', this.context.sampleRate])\n    }\n  },\n\n  /**\n   * Add listener for specified event type.\n   *\n   * @param {\"start\"|\"stop\"|\"pause\"|\"resume\"|\"dataavailable\"} type Event type.\n   * @param {function} listener The listener function.\n   *\n   * @return {undefined}\n   *\n   * @example\n   * recorder.addEventListener('dataavailable', function (e) {\n   *   audio.src = URL.createObjectURL(e.data)\n   * })\n   */\n  addEventListener: function addEventListener () {\n    this.em.addEventListener.apply(this.em, arguments)\n  },\n\n  /**\n   * Remove event listener.\n   *\n   * @param {\"start\"|\"stop\"|\"pause\"|\"resume\"|\"dataavailable\"} type Event type.\n   * @param {function} listener The same function used in `addEventListener`.\n   *\n   * @return {undefined}\n   */\n  removeEventListener: function removeEventListener () {\n    this.em.removeEventListener.apply(this.em, arguments)\n  },\n\n  /**\n   * Calls each of the listeners registered for a given event.\n   *\n   * @param {Event} event The event object.\n   *\n   * @return {boolean} Is event was no canceled by any listener.\n   */\n  dispatchEvent: function dispatchEvent () {\n    this.em.dispatchEvent.apply(this.em, arguments)\n  }\n}\n\n/**\n * Returns `true` if the MIME type specified is one the polyfill can record.\n *\n * This polyfill supports only `audio/wav`.\n *\n * @param {string} mimeType The mimeType to check.\n *\n * @return {boolean} `true` on `audio/wav` MIME type.\n */\nMediaRecorder.isTypeSupported = function isTypeSupported(mimeType) {\n  return /audio\\/wave?/.test(mimeType)\n}\n\n/**\n * `true` if MediaRecorder can not be polyfilled in the current browser.\n * @type {boolean}\n *\n * @example\n * if (MediaRecorder.notSupported) {\n *   showWarning('Audio recording is not supported in this browser')\n * }\n */\nMediaRecorder.notSupported = !navigator.mediaDevices || !AudioContext;\n/**\n * Converts RAW audio buffer to compressed audio files.\n * It will be loaded to Web Worker.\n * By default, WAVE encoder will be used.\n * @type {function}\n *\n * @example\n * MediaRecorder.prototype.mimeType = 'audio/ogg'\n * MediaRecorder.encoder = oggEncoder\n */\nMediaRecorder.encoder = encoder;\n\nexport default MediaRecorder\n","export default function createWorker(fn) {\n    var js = fn\n        .toString()\n        .replace(/^function\\s*\\(\\)\\s*{/, '')\n        .replace(/}$/, '')\n    var blob = new Blob([js])\n    return new Worker(URL.createObjectURL(blob))\n}","// Copied from https://github.com/chris-rudmin/Recorderjs\n\nexport default function waveEncoder() {\n  var BYTES_PER_SAMPLE = 2\n\n  var recorded = []\n\n  function encode (buffer) {\n    var length = buffer.length\n    var data = new Uint8Array(length * BYTES_PER_SAMPLE)\n    for (var i = 0; i < length; i++) {\n      var index = i * BYTES_PER_SAMPLE\n      var sample = buffer[i]\n      if (sample > 1) {\n        sample = 1\n      } else if (sample < -1) {\n        sample = -1\n      }\n      sample = sample * 32768\n      data[index] = sample\n      data[index + 1] = sample >> 8\n    }\n    recorded.push(data)\n  }\n\n  function dump (sampleRate) {\n    var bufferLength = recorded.length ? recorded[0].length : 0\n    var length = recorded.length * bufferLength\n    var wav = new Uint8Array(44 + length)\n    var view = new DataView(wav.buffer)\n\n    // RIFF identifier 'RIFF'\n    view.setUint32(0, 1380533830, false)\n    // file length minus RIFF identifier length and file description length\n    view.setUint32(4, 36 + length, true)\n    // RIFF type 'WAVE'\n    view.setUint32(8, 1463899717, false)\n    // format chunk identifier 'fmt '\n    view.setUint32(12, 1718449184, false)\n    // format chunk length\n    view.setUint32(16, 16, true)\n    // sample format (raw)\n    view.setUint16(20, 1, true)\n    // channel count\n    view.setUint16(22, 1, true)\n    // sample rate\n    view.setUint32(24, sampleRate, true)\n    // byte rate (sample rate * block align)\n    view.setUint32(28, sampleRate * BYTES_PER_SAMPLE, true)\n    // block align (channel count * bytes per sample)\n    view.setUint16(32, BYTES_PER_SAMPLE, true)\n    // bits per sample\n    view.setUint16(34, 8 * BYTES_PER_SAMPLE, true)\n    // data chunk identifier 'data'\n    view.setUint32(36, 1684108385, false)\n    // data chunk length\n    view.setUint32(40, length, true)\n\n    for (var i = 0; i < recorded.length; i++) {\n      wav.set(recorded[i], i * bufferLength + 44)\n    }\n\n    recorded = []\n    postMessage(wav.buffer, [wav.buffer])\n  }\n\n  onmessage = function (e) {\n    if (e.data[0] === 'encode') {\n      encode(e.data[1])\n    } else {\n      dump(e.data[1])\n    }\n  }\n}\n"],"names":["AudioContext","window","webkitAudioContext","MediaRecorder","stream","js","blob","state","em","document","createDocumentFragment","encoder","toString","replace","Blob","Worker","URL","createObjectURL","recorder","this","addEventListener","e","event","Event","data","type","mimeType","dispatchEvent","prototype","start","timeslice","context","input","createMediaStreamSource","processor","createScriptProcessor","onaudioprocess","postMessage","inputBuffer","getChannelData","connect","destination","slicing","setInterval","requestData","stop","clearInterval","pause","resume","sampleRate","apply","arguments","removeEventListener","isTypeSupported","test","notSupported","navigator","mediaDevices","BYTES_PER_SAMPLE","recorded","onmessage","buffer","length","Uint8Array","i","index","sample","push","encode","bufferLength","wav","view","DataView","setUint32","setUint16","set","dump"],"mappings":"IAGIA,EAAeC,OAAOD,cAAgBC,OAAOC,mBAcjD,SAASC,EAAcC,GCjBR,IACPC,EAIAC,ODiBDF,OAASA,OAMTG,MAAQ,gBAERC,GAAKC,SAASC,8BACdC,SC9BCN,ED8BsBF,EAAcQ,QC7BnCC,WACAC,QAAQ,uBAAwB,IAChCA,QAAQ,KAAM,IACfP,EAAO,IAAIQ,KAAK,CAACT,IACd,IAAIU,OAAOC,IAAIC,gBAAgBX,SD2BpCY,EAAWC,UACVR,QAAQS,iBAAiB,UAAW,SAAUC,OAC7CC,EAAQ,IAAIC,MAAM,iBACtBD,EAAME,KAAO,IAAIV,KAAK,CAACO,EAAEG,MAAO,CAAEC,KAAMP,EAASQ,WACjDR,EAASV,GAAGmB,cAAcL,GACH,aAAnBJ,EAASX,OACXW,EAASV,GAAGmB,cAAc,IAAIJ,MAAM,WAK1CpB,EAAcyB,UAAY,CAKxBF,SAAU,YAgBVG,MAAO,SAAgBC,MACF,aAAfX,KAAKZ,MAAsB,MACxBA,MAAQ,iBAERwB,QAAU,IAAI/B,MACfgC,EAAQb,KAAKY,QAAQE,wBAAwBd,KAAKf,QAClD8B,EAAYf,KAAKY,QAAQI,sBAAsB,KAAM,EAAG,GAExDjB,EAAWC,KACfe,EAAUE,eAAiB,SAAUf,GACZ,cAAnBH,EAASX,OACXW,EAASP,QAAQ0B,YAAY,CAC3B,SAAUhB,EAAEiB,YAAYC,eAAe,MAK7CP,EAAMQ,QAAQN,GACdA,EAAUM,QAAQrB,KAAKY,QAAQU,kBAE1BjC,GAAGmB,cAAc,IAAIJ,MAAM,UAE5BO,SACGY,QAAUC,YAAY,WACF,cAAnBzB,EAASX,OAAuBW,EAAS0B,eAC5Cd,MAeTe,KAAM,WACe,aAAf1B,KAAKZ,aACFqC,mBACArC,MAAQ,WACbuC,cAAc3B,KAAKuB,WAcvBK,MAAO,WACc,cAAf5B,KAAKZ,aACFA,MAAQ,cACRC,GAAGmB,cAAc,IAAIJ,MAAM,YAcpCyB,OAAQ,WACa,WAAf7B,KAAKZ,aACFA,MAAQ,iBACRC,GAAGmB,cAAc,IAAIJ,MAAM,aAcpCqB,YAAa,WACQ,aAAfzB,KAAKZ,YACFI,QAAQ0B,YAAY,CAAC,OAAQlB,KAAKY,QAAQkB,cAiBnD7B,iBAAkB,gBACXZ,GAAGY,iBAAiB8B,MAAM/B,KAAKX,GAAI2C,YAW1CC,oBAAqB,gBACd5C,GAAG4C,oBAAoBF,MAAM/B,KAAKX,GAAI2C,YAU7CxB,cAAe,gBACRnB,GAAGmB,cAAcuB,MAAM/B,KAAKX,GAAI2C,aAazChD,EAAckD,gBAAkB,SAAyB3B,SAChD,eAAe4B,KAAK5B,IAY7BvB,EAAcoD,cAAgBC,UAAUC,eAAiBzD,EAWzDG,EAAcQ,QE3Od,eACM+C,EAAmB,EAEnBC,EAAW,GA6DfC,UAAY,SAAUvC,GACF,WAAdA,EAAEG,KAAK,YA5DIqC,WACXC,EAASD,EAAOC,OAChBtC,EAAO,IAAIuC,WAAWD,EAASJ,GAC1BM,EAAI,EAAGA,EAAIF,EAAQE,IAAK,KAC3BC,EAAQD,EAAIN,EACZQ,EAASL,EAAOG,GAChBE,EAAS,EACXA,EAAS,EACAA,GAAU,IACnBA,GAAU,GAGZ1C,EAAKyC,GADLC,GAAkB,MAElB1C,EAAKyC,EAAQ,GAAKC,GAAU,EAE9BP,EAASQ,KAAK3C,GA8CZ4C,CAAO/C,EAAEG,KAAK,aA3CHyB,OACToB,EAAeV,EAASG,OAASH,EAAS,GAAGG,OAAS,EACtDA,EAASH,EAASG,OAASO,EAC3BC,EAAM,IAAIP,WAAW,GAAKD,GAC1BS,EAAO,IAAIC,SAASF,EAAIT,QAG5BU,EAAKE,UAAU,EAAG,YAAY,GAE9BF,EAAKE,UAAU,EAAG,GAAKX,GAAQ,GAE/BS,EAAKE,UAAU,EAAG,YAAY,GAE9BF,EAAKE,UAAU,GAAI,YAAY,GAE/BF,EAAKE,UAAU,GAAI,IAAI,GAEvBF,EAAKG,UAAU,GAAI,GAAG,GAEtBH,EAAKG,UAAU,GAAI,GAAG,GAEtBH,EAAKE,UAAU,GAAIxB,GAAY,GAE/BsB,EAAKE,UAAU,GAAIxB,EAAaS,GAAkB,GAElDa,EAAKG,UAAU,GAAIhB,GAAkB,GAErCa,EAAKG,UAAU,GAAI,EAAIhB,GAAkB,GAEzCa,EAAKE,UAAU,GAAI,YAAY,GAE/BF,EAAKE,UAAU,GAAIX,GAAQ,OAEtB,IAAIE,EAAI,EAAGA,EAAIL,EAASG,OAAQE,IACnCM,EAAIK,IAAIhB,EAASK,GAAIA,EAAIK,EAAe,IAG1CV,EAAW,GACXtB,YAAYiC,EAAIT,OAAQ,CAACS,EAAIT,SAO3Be,CAAKvD,EAAEG,KAAK"}